# Назначение

Это директория, в которой находятся заголовочные файлы для описания архитектуры многопоточности.

# Определения

* Поток (_Thread_) - вычислительная единица, выполняемая фреймворком, и рассматриваемая внутри 
него как отдельная подпрограмма, имеющая общее пространство выполнения с другими потоками.
Это не обычный поток, как в операционных системах, а виртуальный, который позволяет выполняться
внутри одного из php процессов.

* Пул потоков (_Pool_) - объект, который содержит массив работающих потоков, и позволяющий
управлять ими в рантайме.

# Описание

* **[AbstractThreadPool](Pool.php)** - абстрактный класс,
    описывающий возможности пула потоков и управления им.
* **[AbstractThread](Thread.php)** - абстрактный класс,
    описывающий возможности управления потоком для окружающего мира.
* **[MultiThreadingInterface](MultiThreadingInterface.php)** - интерфейс,
    описывающий структуру класса приложения, которую необходимо реализовать для работы с потоками.
    Т.е. интерфейс описывает необходимые возможности для многопоточной работы.
* **[MultiplexingInterface](MultiplexingInterface.php)** - интерфейс,
    описывающий структуру класса потока, который необходимо реализовать
    для работы потока в режиме мультиплексирования.
* **[SynchronizeException](Syncronizer/SynchronizeException.php)** - исключение типа
    "Исключение во время синхронизации" в контексте многопоточности,
    т.е. какая-либо ошибка/исключение при синхронизации работы потоков.

# Как работает

## С точки зрения _Application_

Тут все просто. Приложение в пуле потоков создает какой-то поток, и он передается контроллеру
на дальнейшее распределение между воркерами. При этом для _Application_ пул потоков выглядит
как управляющая структура, при помощи которой можно удаленно управлять потоками. После выполнения
поток возвращается вместе с результатом своего выполнения.

## С точки зрения _Controller_

Контроллер принимает потоки от точки входа, а также от воркеров. Он по специальному алгоритму
распределяет выполнение всех потоков по разным воркерам, отслеживает их корректное выполнение,
принимает результат выполнения потоков от воркеров, и возвращает его постановщику задачи, а это
либо другой (не обязательно другой) воркер, либо входной скрипт (изначально это он). В дальнейшем
схема может немного поменяться (01.03.2017 1:41).

## С точки зрения _Worker_

Все так же как с точки зрения _Application_ во входном скрипте, но с одной фичей: внутри воркера
потоки могут выполняться попеременке (т.е. в режиме мультиплексирования), соответственно
воркер следит за последовательным выполнением потоков.